import matplotlib as mpl
mpl.use('Agg')
import ReadGrid
import numpy as np
from numpy import deg2rad
import h5py
import sys
import matplotlib.pyplot as plt
import matplotlib.tri as tri
from scipy.sparse import csr_matrix
from shapely.geometry import Polygon

def main():
    N = int(sys.argv[1])        # geodesic grid recursion level


    r = 1.0                     # spherical radius

    # Load geodesic grid corresponding to level N
    Grid = ReadGrid.read_grid(N)

    # Get a list of and number of nodes in the geodesic grid
    nodes = Grid.nodes
    gg_node_num = len(nodes)

    test = np.zeros(gg_node_num)

    for i in range(len(nodes)):
        node_main = nodes[i]

        lat0, lon0 = [node_main.lat, node_main.lon]

        test[i] = np.cos(lat0)**2.0 + (1 + np.sin(2*lon0))


    for i in range(len(nodes)):
        node_main = nodes[i]

        f_num = len(node_main.friends)
        if node_main.friends[-1] < 0:
            f_num -= 1

        V = np.zeros((f_num, 6))



        lat0, lon0 = [node_main.lat, node_main.lon]

        s = np.zeros(f_num)

        V[:, 0] = 1.0
        for j in range(f_num):
            f_ID = node_main.friends[j]

            node_f = nodes[f_ID]
            s[j] = test[f_ID]

            lat1, lon1 = [node_f.lat, node_f.lon]



            xf, yf = sph2map(lat0, lon0, lat1, lon1, r)


            V[j, 0+1] = xf
            V[j, 1+1] = yf
            V[j, 2+1] = xf**2.0
            V[j, 3+1] = xf*yf
            V[j, 4+1] = yf**2.0
        
        # print(np.linalg.slogdet(np.matmul(V.T, V)))

        # u,s,v=np.linalg.svd(V)
        # Ainv=np.dot(v.transpose(),np.dot(np.diag(s**-1),u.transpose()))

        # print(Ainv)
        interpOperator = np.matmul(np.linalg.pinv(np.matmul(V.T, V)), V.T) 

        print(interpOperator)

        c = np.matmul(interpOperator, s)

        # print(test[f_ID], xf*c[0] + yf*c[1] + xf**2.0*c[2] + xf*yf*c[3] + yf**2.0*c[4])
        # print(test[f_ID], c[0] + xf*c[0+1] + yf*c[1+1] + xf**2.0*c[2+1] + xf*yf*c[3+1] + yf**2.0*c[4+1])


        



            

    




def get_interpolation_weights(lat1, lon1, polygon_primary, intersection_polygons, gg_polygons, r):
    """
    Function to find the interpolation weights for a cell (primary_polygon), given
    all the cells that intersect it (gg_polygons) and the polygons generated by
    the intersection of primary_polygon and gg_polygons (intersection_polygons).
    """

    area_primary = polygon_primary.area
    intersect_no = len(intersection_polygons)

    weights = [[0., 0., 0.,] for i in range(intersect_no)]

    # The following functions represent the integrands of equations 12 - 14 in
    # Jones (1998). The first integrand is used for 1st order accurate conservative
    # mapping, while the second and third are used for 2nd order accurate
    # conservative mapping.

    def weight1_integrand(lats, lons):
        return -np.sin(lats)

    def weight2_integrand(lats, lons):
        return -np.cos(lats) - lats*np.sin(lats)

    def weight3_integrand(lats, lons):
        return -0.5*lons*(np.sin(lats)*np.cos(lats) + lats)

    # Loop over every polygon that intersects with polygon_primary and evaluate
    # the three weighting coefficients for each one.
    for i in range(intersect_no):
        # Calculate weight one
        integral = line_integral(intersection_polygons[i], weight1_integrand, lat1, lon1, r)
        weights[i][0] = integral/area_primary


        # Calculate weight two
        integral = line_integral(intersection_polygons[i], weight2_integrand, lat1, lon1, r)
        weights[i][1] = integral/area_primary

        integral = line_integral(gg_polygons[i], weight2_integrand, lat1, lon1, r)
        weights[i][1] -= weights[i][0]/gg_polygons[i].area * integral


        # Calculate weight three
        integral = line_integral(intersection_polygons[i], weight3_integrand, lat1, lon1, r)
        weights[i][2] = integral/area_primary

        integral = line_integral(gg_polygons[i], weight3_integrand, lat1, lon1, r)
        weights[i][2] -= weights[i][0]/gg_polygons[i].area * integral

    return weights




def sph2map(lat1,lon1,lat2,lon2, r):
    """
    Find the projected xy coordinates of the point latlon2 around latlon1 using
    a stereographic projection. The inverse of this function is map2sph.
    """

    m = 2.0 / (1.0 + np.sin(lat2)*np.sin(lat1) + np.cos(lat1)*np.cos(lat2)*np.cos(lon2-lon1))
    x = m * r * np.cos(lat2) * np.sin(lon2 - lon1)
    y = m * r * (np.sin(lat2)*np.cos(lat1) - np.cos(lat2)*np.sin(lat1)*np.cos(lon2-lon1))

    return np.array([x, y])




def map2sph(lat1, lon1, x, y, r, trig=False):
    """
    Find the latlon coordinates from the projected coordinates xy about the point
    latlon1 using a stereographic projection. This function is the inverse of
    sph2map.
    """

    rho = np.sqrt(x**2. + y**2.)
    c = 2. *np.arctan2(rho, 2.*r)

    sinLat = np.cos(c)*np.sin(lat1) + y*np.sin(c)*np.cos(lat1)/rho
    lat = np.arcsin(sinLat)

    lon = lon1 + np.arctan2(x*np.sin(c), (rho*np.cos(lat1)*np.cos(c) - y*np.sin(lat1)*np.sin(c)))
    if not trig:
        return np.array([lat, lon])
    else:
        return np.array([lat, lon, sinLat])




def test_interp(N, grid, ll_lat, ll_lon, dx, r):
    """
    Test the interpolation of geodesic grid N to latlon resolution dx. Returns
    the max and mean error of the interpolation.
    """

    file_name = "grid_l" + str(N) + "_" + str(int(dx)) + "x" + str(int(dx)) + "_weights.h5"

    f= h5py.File(file_name, 'r')

    cols = f["column index"]
    rows = f["row index"]
    w    = f["weights"]

    map_matrix = csr_matrix((w, cols, rows), shape=(len(ll_lat)*len(ll_lon), 3*len(grid.nodes)))

    m = 2.
    n = 3.

    ll_x, ll_y = np.meshgrid(ll_lon, ll_lat)

    tf_ll = np.cos(m*ll_x) * np.cos(n*ll_y)**4. #+ 0.001*np.cos(3*m*ll_x) * np.cos(3*n*ll_y)

    gg_lat, gg_lon = np.array(grid.lats), np.array(grid.lons)
    triang = tri.Triangulation(gg_lon, gg_lat)

    tf_gg = np.cos(m*gg_lon) * np.cos(n*gg_lat)**4. #+ 0.001*np.cos(3*m*gg_lon) * np.cos(3*n*gg_lat)
    tf_gg_dlat = 1./r * (-4.*n*np.sin(n*gg_lat)*np.cos(n*gg_lat)**3. *np.cos(m*gg_lon)) #+ -3.*n*0.001*np.cos(3*m*gg_lon) * np.sin(3*n*gg_lat))
    tf_gg_dlon = 1./r * (-m*np.sin(m*gg_lon)*np.cos(n*gg_lat)**4. )/np.cos(gg_lat) #- 3.*m* 0.001*np.sin(3*m*gg_lon) * np.cos(3*n*gg_lat)

    gg_data = np.zeros(3*len(grid.nodes))
    ll_interp = np.zeros(len(ll_lat)*len(ll_lon))

    for i in range(len(grid.nodes)):
        gg_data[3*i]        = tf_gg[i]
        gg_data[3*i + 1]    = tf_gg_dlat[i]
        gg_data[3*i + 2]    = tf_gg_dlon[i]

    ll_interp = map_matrix.dot(gg_data)
    ll_interp = np.reshape(ll_interp, (len(ll_lat), len(ll_lon)))

    fig, (ax1, ax2, ax3, ax4) = plt.subplots(ncols=4, figsize=(16,3.5))

    vmax = max(np.amax(ll_interp), max(np.amax(tf_ll), np.amax(tf_gg)))
    vmin = min(np.amin(ll_interp), min(np.amin(tf_ll), np.amin(tf_gg)))

    levels = np.linspace(vmin, vmax, 9)
    levels2 = 1e3*np.linspace(np.amin(ll_interp-tf_ll), np.amax(ll_interp-tf_ll), 9)

    axes = [ax1, ax2, ax3, ax4]

    # tf_ll2 = np.cos(m*ll_x) * np.cos(n*ll_y)**4.

    # tf_ll = np.cos(m*ll_x) * np.cos(n*ll_y)**4.

    c1 = ax1.contourf(ll_lon, ll_lat, tf_ll, levels=levels)
    c2 = ax2.tricontourf(triang, tf_gg, levels=levels)
    c3 = ax3.contourf(ll_lon, ll_lat, ll_interp, levels=levels)
    c4 = ax4.contourf(ll_lon, ll_lat, 1e3*(ll_interp-tf_ll))

    c = [c1, c2, c3, c4]

    for cb, ax in zip(c,axes):
        ax.set_ylim([-np.pi*0.5, np.pi*0.5])
        ax.set_aspect('equal')
        plt.colorbar(cb, ax=ax, orientation='horizontal')

    max_err = np.amax(abs(ll_interp-tf_ll))
    mean_err = np.mean(abs(ll_interp.flatten()-tf_ll.flatten()))

    print("Max error:", max_err, ", Mean error:", mean_err)

    ax1.set_title("Lat-lon grid (analytic)")
    ax2.set_title("Geodesic grid (analytic)")
    ax3.set_title("Interpolated solution")
    ax4.set_title("Interpolated - analytic solution ($\\times 10^3$)")

    fig.savefig("/home/hamish/Dropbox/Tests/conservative_interp_test_g6_1x1.pdf")
    plt.show()

    return max_err, mean_err




def SaveWeightingMatrix(N, dx, cols, rows, data):
    """
    Save the weighting coefficients (data) to an hdf5 file. Cols and rows are
    the row and column indices, in csr format, and are also saved.
    """

    file_name = "grid_l" + str(N) + "_" + str(int(dx)) + "x" + str(int(dx)) + "_weights.h5"
    print("Saving mapping matrix in CSR format to " + file_name)

    f = h5py.File(file_name, 'w')

    dset_cols = f.create_dataset("column index", (len(cols), ), dtype='i')
    dset_cols[:] = cols[:]

    dset_rows = f.create_dataset("row index", (len(rows), ), dtype='i')
    dset_rows[:] = rows[:]

    dset_data = f.create_dataset("weights", (len(data), ), dtype='d')
    dset_data[:] = data[:]

    dset_data.attrs["non-zero elements"] = len(data)

    f.close()


if __name__=='__main__':
    main()
